# Little Endian & Big Endian



## Endian 은 컴퓨터에서 데이터가 저장되는 순서(byte order)를 말한다.

![](http://mohwa.github.io/blog/assets/images/posts/bytesManipulation_5.jpg)

- 메모리는 하위 주소에서 상위 주소로 데이터가 저장된다. //  스택처럼 쌓이는 구조

- Little Endian: 하위 바이트부터 데이터가 저장되는 방식.
  
  주로 인텔프로세서 계열에서 사용하는 바이트 오더
  
  - Little Endian 방식의 장점: 산술연산유닛(ALU)에서 메모리를 읽는 방식이 메모리 주소가 낮은 쪽에서부터 높은 쪽으로 읽기 때문에 산술 연산의 수행이 더 쉽다.(*연산 처리 과정에서 이런 장점이 있는 정도로만 알고 넘어가자…*)
  
  예를 들어서 메모리주소가 0x01020304이면
  
    하위 주소   =>  상위 주소
  
  | 0x04 | 0x03 | 0x02 | 0x01 |
  | ---- | ---- | ---- | ---- |
  
  

- Big Endian: 상위 바이트부터 데이터가 저장되는 방식.
  
  주로 유닉스를 사용하는 RISC프로세서 계열에서 사용하는 바이트오더

| 0x01 | 0x02 | 0x03 | 0x04 |
| ---- | ---- | ---- | ---- |

**네트워크 프로토콜에서는 바이트 오더로 빅엔디안을 따르도록 하고 있으므로 흔히 intel계열 프로세서를 사용하는 PC환경에서는 리틀엔디언 -> 빅 엔디언 또는 빅엔디언 -> 리틀엔디언으로 변경처리를 잘 해야 합니다. (htonl, ntohl, inet_addr 등 주로 사용)**



바이트 오더(데이터 저장순서)는 동일한 시스템 안에서는 문제가 없지만 이기종 간에 데이터를 주고받을 시에는 데이터 저장방식 차이로 이상한 결과를 반환하게 됩니다.

#### ! 해결책 2가지

1. 공통된 Endian으로 변환 후 데이터를 주고 받는 방법을 해결책으로 내놓았습니다. 서로간에 사용할 엔디언을 하나로 통일시켜 데이터 통신을 하는 것

2. 바이트 오더를 신경 쓸 필요가 없는 데이터타입을 사용하는 것. char 타입은 1byte의 크기를 가지므로 byte order를 신경쓸 필요가 없습니다. char 형으로 문자열 변환시켜 전송을 하는 방법이 있습니다. 




















